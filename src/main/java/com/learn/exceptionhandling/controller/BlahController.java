package com.learn.exceptionhandling.controller;

import com.learn.exceptionhandling.exception.BlahException;
import com.learn.exceptionhandling.i18n.ExceptionMessageBundle;
import com.learn.exceptionhandling.i18n.ExceptionMessageKeys;
import com.learn.exceptionhandling.service.BlahService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping(path = "/blah", produces = MediaType.APPLICATION_JSON_VALUE)
@RequiredArgsConstructor
public class BlahController {

    private final BlahService blahService;

    @GetMapping("/response-status-exception")
    public Object throwResponseStatusException() {
        try {
            return blahService.throwBlahException();
        } catch (BlahException ex) {
            log.error("response-status-exception: {}", ex.getMessage());
            String localizedErrorMessage = ExceptionMessageBundle.getLocalizedMessage(ExceptionMessageKeys.I_AM_TEAPOT, new Locale("UA"));

            throw new ResponseStatusException(HttpStatus.I_AM_A_TEAPOT, localizedErrorMessage, ex);

            // This will generate response:
            // {
            //    "type": "about:blank",
            //    "title": "I'm a teapot",
            //    "status": 418,
            //    "detail": "Трясця, я - чайник!",
            //    "instance": "/blah/response-status-exception"
            // }
            // TODO: research if it can be customized to
            //  the response generated by Annotated Exception:
            // {
            //    "timestamp": "2025-01-19T17:25:13.742+00:00",
            //    "status": 418,
            //    "error": "I'm a teapot",
            //    "message": "Трясця, я - анотований чайник!",
            //    "path": "/blah/annotated-blah-exception"
            // }
        }
    }

    @GetMapping("/blah-exception")
    public Object throwBlahException() {
        return blahService.throwBlahException();
    }

    @GetMapping("/another-blah-exception")
    public Object throwAnotherBlahException() {
        return blahService.throwAnotherBlahException();
    }

    @GetMapping("/unknown-blah-exception")
    public Object throwUnknownBlahException() {
        return blahService.throwUnknownBlahException();
    }

    @GetMapping("/annotated-blah-exception")
    public Object throwAnnotatedBlahException() {
        return blahService.throwAnnotatedBlahException();
    }

    // ----------------------------------------
    //  some end-points that return data:
    // ----------------------------------------

    @GetMapping(path = "/test/public")
    public Object testPublic () {
        return List.of("blah", "test", "public");
    }

    @GetMapping(path = "/test/public/{testId}")
    public Object testPublicWithPathVariable (@PathVariable Long testId) {
        return List.of("blah", "test", "public", testId);
    }

    @GetMapping(path = "/test/user")
    @PreAuthorize("hasAnyRole('USER', 'ADMIN')") // requires @EnableMethodSecurity
    public Object testUser () {
        return List.of("blah", "test", "user");
    }

    @PostMapping(path = "/test/admin")
    @PreAuthorize("hasRole('ADMIN')") // requires @EnableMethodSecurity
    public Object testAdmin (@RequestBody Object data) {
        Map<String, Object> response = new HashMap<>();
        response.put("blah", "blah");
        response.put("data", data);
        return response;
    }
}
